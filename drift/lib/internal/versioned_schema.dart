/// Defines base classes to generate lightweight tables and views. This library
/// is used by code generated via `drift_dev schema steps` to generate snapshots
/// of every schema version of your database without much overhead.
///
/// For more information on how to use that feature, see
/// https://drift.simonbinder.eu/docs/advanced-features/migrations/#step-by-step
///
/// __Warning:__ This library is not meant to be imported into user-written
/// code, and classes defined in this library are not part of drift's stable
/// API.
library;

import 'package:drift/drift.dart';

/// A snapshot of a database schema at a previous version.
///
/// This class is meant to be extended by generated code.
abstract base class VersionedSchema {
  /// The generated database instance, used to create [TableInfo] instances.
  final DatabaseConnectionUser database;

  /// The [GeneratedDatabase.schemaVersion] at the time this schema was active.
  final int version;

  /// Default constructor taking the database and the schema version.
  VersionedSchema({required this.database, required this.version});

  /// All drift schema entities at the time of the set [version].
  Iterable<DatabaseSchemaEntity> get entities;
}

/// A drift table implementation that, instead of being generated, is constructed
/// from individual fields
///
/// This allows the code generated for step-by-step migrations to be a lot
/// smaller than the code typically generated by drift. Features like type
/// converters or information about unique/primary keys are not present in these
/// tables.
class VersionedTable extends Table with TableInfo<Table, QueryRow> {
  @override
  final String entityName;
  final String? _alias;
  @override
  final bool isStrict;

  @override
  final bool withoutRowId;

  @override
  final DatabaseConnectionUser attachedDatabase;

  @override
  final List<GeneratedColumn> $columns;

  /// List of columns, represented as a function that returns the generated
  /// column when given the resolved table name.
  final List<GeneratedColumn Function(String)> _columnFactories;

  @override
  final List<String> customConstraints;

  /// Create a table from the individual fields.
  ///
  /// [columns] is a list of functions returning a [GeneratedColumn] when given
  /// the alias (or original name) of this table.
  VersionedTable({
    required this.entityName,
    required this.isStrict,
    required this.withoutRowId,
    required this.attachedDatabase,
    required List<GeneratedColumn Function(String)> columns,
    required List<String> tableConstraints,
    String? alias,
  })  : _columnFactories = columns,
        customConstraints = tableConstraints,
        $columns = [for (final column in columns) column(alias ?? entityName)],
        _alias = alias;

  /// Create a table by copying fields from [source] and applying an [alias].
  VersionedTable.aliased({
    required VersionedTable source,
    required String? alias,
  })  : entityName = source.entityName,
        isStrict = source.isStrict,
        withoutRowId = source.withoutRowId,
        attachedDatabase = source.attachedDatabase,
        customConstraints = source.customConstraints,
        _columnFactories = source._columnFactories,
        $columns = [
          for (final column in source._columnFactories)
            column(alias ?? source.entityName)
        ],
        _alias = alias;

  @override
  String get actualTableName => entityName;

  @override
  String get aliasedName => _alias ?? entityName;

  @override
  bool get dontWriteConstraints => true;

  @override
  QueryRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    return QueryRow(data, attachedDatabase);
  }

  @override
  VersionedTable createAlias(String alias) {
    return VersionedTable.aliased(source: this, alias: alias);
  }
}

/// The version of [VersionedTable] for virtual tables.
class VersionedVirtualTable extends VersionedTable
    with VirtualTableInfo<Table, QueryRow> {
  @override
  final String moduleAndArgs;

  /// Create a small virtual table from the individual fields.
  VersionedVirtualTable({
    required super.entityName,
    required super.attachedDatabase,
    required super.columns,
    required this.moduleAndArgs,
    super.alias,
  }) : super(
          isStrict: false,
          withoutRowId: false,
          tableConstraints: [],
        );

  /// Create a virtual table by copying fields from [source] and applying a
  /// [alias] to columns.
  VersionedVirtualTable.aliased(
      {required VersionedVirtualTable source, required String? alias})
      : moduleAndArgs = source.moduleAndArgs,
        super.aliased(source: source, alias: alias);

  @override
  VersionedVirtualTable createAlias(String alias) {
    return VersionedVirtualTable.aliased(
      source: this,
      alias: alias,
    );
  }
}

/// A constructed from individual fields instead of being generated with a
/// dedicated class.
class VersionedView implements ViewInfo<HasResultSet, QueryRow>, HasResultSet {
  @override
  final String entityName;
  final String? _alias;

  @override
  final String createViewStmt;

  @override
  final List<GeneratedColumn> $columns;

  @override
  late final Map<String, GeneratedColumn> columnsByName = {
    for (final column in $columns) column.name: column,
  };

  /// List of columns, represented as a function that returns the generated
  /// column when given the resolved table name.
  final List<GeneratedColumn Function(String)> _columnFactories;

  @override
  final DatabaseConnectionUser attachedDatabase;

  /// Create a view from the individual fields on [ViewInfo].
  VersionedView({
    required this.entityName,
    required this.attachedDatabase,
    required this.createViewStmt,
    required List<GeneratedColumn Function(String)> columns,
    String? alias,
  })  : _columnFactories = columns,
        $columns = [for (final column in columns) column(alias ?? entityName)],
        _alias = alias;

  /// Copy an alias to a [source] view.
  VersionedView.aliased({required VersionedView source, required String? alias})
      : entityName = source.entityName,
        attachedDatabase = source.attachedDatabase,
        createViewStmt = source.createViewStmt,
        _columnFactories = source._columnFactories,
        $columns = [
          for (final column in source._columnFactories)
            column(alias ?? source.entityName)
        ],
        _alias = alias;

  @override
  String get aliasedName => _alias ?? entityName;

  @override
  HasResultSet get asDslTable => this;

  @override
  VersionedView createAlias(String alias) {
    return VersionedView.aliased(source: this, alias: alias);
  }

  @override
  QueryRow map(Map<String, dynamic> data, {String? tablePrefix}) {
    return QueryRow(data, attachedDatabase);
  }

  @override
  Query<HasResultSet, dynamic>? get query => null;

  @override
  Set<String> get readTables => const {};
}
